Scala基于jvm  #API=java(scala对java进行包装)+scala特有
.class 与 .scala都可以直接运行   #.scala运行更慢(编译和运行都有)



函数的执行体主要是在 HelloWorld$.class 中，当执行HelloWorld.class 中 的main 方法时，
    会调用方法 HelloWorld.main(null),接着会执行方法体中的代码 HelloWorld..MODULE$.main(paramArrayOfString) ，
    接着函数跳转 HelloWorld$.class 的 main 方法中，然后执行 Predef..MODULE$.println("Hello World");最后输出结果:”Hello World“。



现代编译器：
    堆：当一个对象的声明周期很长，可能会被多个变量引用[不同的栈引用同一个空间]
    栈：数据空间只是临时用一下

var与val:
    1 实际工作中，更多的需求是获取/创建一个对象后，读取该对象的属性，或者修改该对象的属性值(var)，单很少改变这个对象本身(val)
    2 val没有线程安全的问题，因此效率高，scala设计者推荐使用val[源码+final]
    3 如果对象需要改变，使用var


数据类型[没有原声类型，所有的数据类型都是对象]
    2大类:AnyVal(值类型)/AnyRef(引用类型)  #都是对象

类型转换：低精度的值向高精度的值自动转换[隐式转换]
Unit 相当于void  值为()
Null 相当于null引用 null只能赋值给AnyRef 不能赋值给AnyVal
Nothing 最底层可以作为任何类型的子类型-[常用来处理异常]

scala不推荐while(可以使用递归/for循环):while没有返回值，因为没有返回值，就得使用外部变量[循环内部对外部变量造成影响]，所以不推荐，而是推荐使用for循环

================================  函数式编程  ======================================
函数式编程是从编程范式角度来谈，函数式编程把函数当作一等公民，充分利用函数，支持函数的多种使用方式

方法(Method)
函数(function) 像变量一样，既可以作为函数的参数使用，也可以将函数赋值给一个变量，函数的创建不用依赖于对象或者类(在java中函数的创建要依赖于类/抽象类/接口)

    函数内部还可以嵌套函数(生成的函数与普通函数在同一级别[编译后] xxx$ xxx$1[同名]) 调用还是区分函数作用域

    函数的形参是val 修改会编译报错

    递归的返回类型得显示声明不能自动推导  会编译报错

    def f="abc" 是 def f()={"abc"} 的省略形式

    惰性函数：lazy val xxx 不能用var修饰 val固定是线程安全
        也可以适用与变量[控制台代码片段]
            scala> lazy val i=10
            i: Int = <lazy>        #未真正适用

            scala> i
            res6: Int = 10         #真正使用
过程：函数没有返回值称为过程
================================ 异常 ======================================
scala只有运行异常(捕获异常 catch 范围大的可以写在前面不回报错(不推荐)[java会报错，认为范围小的不会被执行])
================================ oop ======================================
对象属性得给个默认值(自己给/_该类型的默认值)

类加载流程：(类似java)
    1 加载类信息(属性信心，方法信息)[到方法区]
    2 在内存中开辟空间(堆)
    3 使用父类构造器(主/辅助构造器)
    4 使用主构造器进行初始化(属性初始化 eg:name="tom")
    5 使用辅助构造器对属性进行初始化
    6 将开辟的空间赋给引用
============================== package ======================================
scala中包名和源码所在系统文件目录结构可能不一样，但是编译后的字节码文件路径和包名会保持一致(编译器完成)
不需引入的包 java.lang  scala Predef
查看包 光标定位 ctrl+b

object会生成 xxx.class和xxx$.class
class xxx只会生成xxx.class

package的三种方式
    1 一级 package xxx.xxx.xxx
    2 二级 package xxx.xxx [换行]package xxx
    3 嵌套 package xxxx.xxx.xxx{package xxxx}
嵌套包的使用 就近原则(同名情况下)(非要使用父包中的类得写全类名) 父包要访问子包得使用import
包对象(解决包中不能直接写变量/函数的情况)(jvm认为变量/函数应该归属于对象)
/**
  * 包对象与包得在同级目录下
  * packageObj对象与packageObj都在com.xxm下
  * 包对象中的属性方法直接使用  参考：com.xxm.re_base.T3_Package
  */




