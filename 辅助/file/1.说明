Scala基于jvm  #API=java(scala对java进行包装)+scala特有
.class 与 .scala都可以直接运行   #.scala运行更慢(编译和运行都有)



函数的执行体主要是在 HelloWorld$.class 中，当执行HelloWorld.class 中 的main 方法时，
    会调用方法 HelloWorld.main(null),接着会执行方法体中的代码 HelloWorld..MODULE$.main(paramArrayOfString) ，
    接着函数跳转 HelloWorld$.class 的 main 方法中，然后执行 Predef..MODULE$.println("Hello World");最后输出结果:”Hello World“。



现代编译器：
    堆：当一个对象的声明周期很长，可能会被多个变量引用[不同的栈引用同一个空间]
    栈：数据空间只是临时用一下

var与val:
    1 实际工作中，更多的需求是获取/创建一个对象后，读取该对象的属性，或者修改该对象的属性值(var)，单很少改变这个对象本身(val)
    2 val没有线程安全的问题，因此效率高，scala设计者推荐使用val[源码+final]
    3 如果对象需要改变，使用var


数据类型[没有原声类型，所有的数据类型都是对象]
    2大类:AnyVal(值类型)/AnyRef(引用类型)  #都是对象

类型转换：低精度的值向高精度的值自动转换[隐式转换]
Unit 相当于void  值为()
Null 相当于null引用 null只能赋值给AnyRef 不能赋值给AnyVal
Nothing 最底层可以作为任何类型的子类型-[常用来处理异常]

scala不推荐while(可以使用递归/for循环):while没有返回值，因为没有返回值，就得使用外部变量[循环内部对外部变量造成影响]，所以不推荐，而是推荐使用for循环

================================  函数式编程  ======================================
函数式编程是从编程范式角度来谈，函数式编程把函数当作一等公民，充分利用函数，支持函数的多种使用方式

方法(Method)
函数(function) 像变量一样，既可以作为函数的参数使用，也可以将函数赋值给一个变量，函数的创建不用依赖于对象或者类(在java中函数的创建要依赖于类/抽象类/接口)

    函数内部还可以嵌套函数(生成的函数与普通函数在同一级别[编译后] xxx$ xxx$1[同名]) 调用还是区分函数作用域

    函数的形参是val 修改会编译报错

    递归的返回类型得显示声明不能自动推导  会编译报错

    def f="abc" 是 def f()={"abc"} 的省略形式

    惰性函数：lazy val xxx 不能用var修饰 val固定是线程安全
        也可以适用与变量[控制台代码片段]
            scala> lazy val i=10
            i: Int = <lazy>        #未真正适用

            scala> i
            res6: Int = 10         #真正使用
过程：函数没有返回值称为过程
================================ 异常 ======================================
scala只有运行异常(捕获异常 catch 范围大的可以写在前面不回报错(不推荐)[java会报错，认为范围小的不会被执行])
================================ oop ======================================
对象属性得给个默认值(自己给/_该类型的默认值)

类加载流程：(类似java)
    1 加载类信息(属性信心，方法信息)[到方法区]
    2 在内存中开辟空间(堆)
    3 使用父类构造器(主/辅助构造器)
    4 使用主构造器进行初始化(属性初始化 eg:name="tom")
    5 使用辅助构造器对属性进行初始化
    6 将开辟的空间赋给引用
============================== package ======================================
scala中包名和源码所在系统文件目录结构可能不一样，但是编译后的字节码文件路径和包名会保持一致(编译器完成)
不需引入的包 java.lang  scala Predef
查看包 光标定位 ctrl+b

object会生成 xxx.class和xxx$.class
class xxx只会生成xxx.class

package的三种方式
    1 一级 package xxx.xxx.xxx
    2 二级 package xxx.xxx [换行]package xxx
    3 嵌套 package xxxx.xxx.xxx{package xxxx}

嵌套包的使用 就近原则(同名情况下)(非要使用父包中的类得写全类名) 父包要访问子包得使用import

包对象(解决包中不能直接写变量/函数的情况)(jvm认为变量/函数应该归属于对象)
/**
  * 包对象与包得在同级目录下
  * packageObj对象与packageObj都在com.xxm下
  * 包对象中的属性方法直接使用  参考：com.xxm.re_base.T3_Package
  调用原理：
        //会生成两个class package.class package$.class
        //属性/方法的调用 package$中的静态实例 public static final MODULE$ 调用属性与方法
  */

同一个文件同时出现 class Xxx(伴生类[非静态]) object Xxx(伴生对象[静态])
包的可见性：T4_Package2
包的引入：可以在任何位置引入(需要时在引用)(有作用域[超出会报错])   xxx._等价与java中的*
protected只能在子类访问  虽然编译后是public 但是不能访问(编译器在编译前控制，不允许访问)

=======================================================
java中成员变量不能像成员方法一样被重写(准确的讲是隐藏代替了重写)。当子类中定义了一个跟父类属性同名的属性时，就是定义了一个新字段。
        这个字段在父类中是被隐藏的，是不可重写的
如何访问隐藏字段：1 使用父类引用 2 将子类对象强转为父类对象
多态使用父类引用调用方法，调用的是子类的方法(因为引用指向的内存地址是子类的)
-----------------小结(java动态绑定)
1 如果调用的是方法，则jvm会将该方法与对象的内存地址绑定
2 如果调用的是属性，则没有动态绑定，在哪里调用，就返回对应的值(根据引用而定)

baseOne:T6_Construct.scala
scala:  访问属性 使用的是方法所以不会根据引用的变化而变化(属性重写得是val)
        [var会报错(可变变量不能被重写)：mutable variable cannot be overridden ]
原理分析：假如var可以被val重写 子类会生成对应的get方法，对属性赋值会调用父类的set方法会赋值给父类属性，
        但是get的时候调用的是子类方法获取的是子类的属性，会造成获取到的属性值不一致现象

-----------------abstract